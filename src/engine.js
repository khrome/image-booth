import { Canvas } from 'environment-safe-canvas';
import { Layer } from './layer.js';
import * as fs from 'fs';
export const setBooth = (booth)=>{ // this is the object we find our various filters/brushes/ops/tools on
    registry = booth;
}

export const tool = (layer, options)=>{ // operate on a path or location
    if(!options.name) throw new Error('engine not linked to image-booth');
    if(!registry.tools[options.name]) throw new Error('image-booth does not have tool '+options.name);
    if(!layer.isCanvas) throw new Error('attempting to work on a layer generated by another engine');
    
}

export const operate = (layer, options)=>{ // custom pixel logic
    if(!options.name) throw new Error('engine not linked to image-booth');
    if(!registry.operations[options.name]) throw new Error('image-booth does not have operation '+options.name);
    if(!layer.isCanvas) throw new Error('attempting to work on a layer generated by another engine');
    
}

/*export const createImage = async (location, callback)=>{
    const canvas = await Canvas.load(location);
    if(callback)
    return canvas;
}*/

export const saveImage = async (location, canvas, type='image/png', callback)=>{
    try{
        const savePromise = Canvas.save(location, canvas, type);
        const result = await savePromise;
        if(callback) callback(null, result);
        return result;
    }catch(ex){
        console.log(callback)
        if(callback) callback(ex)
        else throw ex;
    }
}

/*export const saveImage = (location, pixels, height, width, callback)=>{
    console.log('A');
    return new Promise((resolve, reject)=>{
        console.log('B');
        try{
            var buffer = new Canvas({ height, width });
            const context2d = buffer.getContext('2d');
            const imgData2 = context2d.getImageData(0, 0, width, height);
            imgData2.data = pixels;
            context2d.putImageData(imgData2, 0, 0);
            buffer.toDataURL('image/png', function(err, dataURL){
                console.log('22222', err);
                if(err) return cb(err);
                console.log('<img src="' + dataURL + '" />');
                var base64 = dataURL.substring(dataURL.indexOf(','));
                var buffer = new Buffer(base64, 'base64');
                console.log('??', buffer);
                fs.writeFile(location, buffer, function(err){
                    if(callback) callback(err, buffer);
                    if(err) return reject(err);
                    resolve(buffer);
                })
            });
        }catch(ex){
            console.log('F', ex);
            reject(ex);
        }
    });
}*/

export const newLayer = async (options, callback)=>{
    const layer = new Layer(options);
    await layer.ready;
    callback(layer);
    return layer;
}

export const newImage = (options)=>{ 
    return new Image(options);
}

export const brush = (layer, options)=>{ // paint on a path
    if(!options.name) throw new Error('engine not linked to image-booth');
    if(!registry.brushes[options.name]) throw new Error('image-booth does not have brush '+options.name);
    if(!layer.isCanvas) throw new Error('attempting to work on a layer generated by another engine');
    
}

export const filter = (layer, options)=>{ // convolve
    if(!options.name) throw new Error('engine not linked to image-booth');
    if(!registry.filters[options.name]) throw new Error('image-booth does not have filter '+options.name);
    if(!layer.isCanvas) throw new Error('attempting to work on a layer generated by another engine');
}

export const convolve = function(pixels, filter, filter_div, offset){
    if(!convolveBuffer) convolveBuffer = new Canvas();
    if (pixels == null)throw new Error('Tried to convolve nothing!');
    //setup buffer
    convolveBuffer.setAttribute('width', pixels.width);
    convolveBuffer.setAttribute('height', pixels.height);
    var context = convolveBuffer.getContext('2d');
    var newPixels  = context.getImageData(0,0, pixels.width, pixels.height);
    var sx = pixels.width; //getx
    var sy = pixels.height; //gety
    var new_r, new_g, new_b, new_a, alpha, yv, pxl, new_pxl, kernel_size;
    //kernel_size = filter.length; //coming soon
    for(var y = 0; y < sy; y++){
        for(x = 0; x < sx; x++){
            new_r = new_g = new_b = 0;
            new_a = pixels.data[((y*(sx*4)) + (x*4)) + 3];
            //convolve this pixel to produce this pixel's value
            for(var j = 0; j < filter.length; j++) { //rows
                yv = Math.min( Math.max(y - 1 + j, 0), sy - 1);
                for(var i = 0; i < filter[j].length; i++) { //cols
                    pxl = [ Math.min( Math.max(x - 1 + i, 0), sx - 1), yv]; 
                    if(filter[j] && filter[j][i]){
                        new_r += pixels.data[((pxl[1]*(sx*4)) + (pxl[0]*4))    ] * filter[j][i];
                        new_g += pixels.data[((pxl[1]*(sx*4)) + (pxl[0]*4)) + 1] * filter[j][i];
                        new_b += pixels.data[((pxl[1]*(sx*4)) + (pxl[0]*4)) + 2] * filter[j][i];
                    }
                }
            }
            if ((y >= 0) && (y < sy)) { //y coordinate in range?
                //
                new_r = (new_r/filter_div)+offset;
                new_g = (new_g/filter_div)+offset;
                new_b = (new_b/filter_div)+offset;
                //bound 0 .. 255
                new_r = (new_r > 255)? 255 : ((new_r < 0)? 0:new_r); 
                new_g = (new_g > 255)? 255 : ((new_g < 0)? 0:new_g);
                new_b = (new_b > 255)? 255 : ((new_b < 0)? 0:new_b);
                //copy the altered values for this pixel into the buffer we created
                newPixels.data[((y*(sx*4)) + (x*4))    ] += new_r;
                newPixels.data[((y*(sx*4)) + (x*4)) + 1] += new_g;
                newPixels.data[((y*(sx*4)) + (x*4)) + 2] += new_b;
                newPixels.data[((y*(sx*4)) + (x*4)) + 3] += new_a;
            }
        }
    }
    // return the buffer
    return newPixels;
}

let convolveBuffer = null;

export const merge = function(aPixels, bPixels, buffer, mode, opacity){ //src == image
    if(!convolveBuffer) convolveBuffer = new Canvas({
        width: aPixels.width,
        height: aPixels.height
    });
    //for clarity's sake, we are layering layer a over layer b
    if (aPixels == null || bPixels == null) throw new Error('Tried to convolve nothing!');
    if(aPixels.height != bPixels.height || aPixels.width != bPixels.width){
        throw new Error(`Mismatched pixel size
            data: ${aPixels.data.length} vs ${bPixels.data.length}
            height: ${aPixels.height} vs ${bPixels.height}
            width: ${aPixels.width} vs ${bPixels.width}`);
    }
    if(mode == null) mode = 'overlay';
    //setup buffer
    var newPixels;
    if(!buffer || buffer == null){
        //convolveBuffer.setProperty('width', aPixels.width);
        //convolveBuffer.setProperty('height', aPixels.height);
        convolveBuffer.width = aPixels.width;
        convolveBuffer.height = aPixels.height;
        var context = convolveBuffer.getContext('2d');
        newPixels  = context.getImageData(0,0, aPixels.width, aPixels.height);
    }else{
        newPixels = buffer.getImageData(0,0, aPixels.width, aPixels.height);
    }
    var sx = aPixels.width; //getx
    var sy = aPixels.height; //gety
    switch(mode){
        case 'average':
            
            break;
        case 'lighten':
            for(var y = 0; y < sy; y++){
                for(x = 0; x < sx; x++){
                    newPixels.data[((y*(sx*4)) + (x*4))     ] = Math.max(
                        aPixels.data[((y*(sx*4)) + (x*4))     ],
                        bPixels.data[((y*(sx*4)) + (x*4))     ]
                    );
                    newPixels.data[((y*(sx*4)) + (x*4)) + 1 ] = Math.max(
                        aPixels.data[((y*(sx*4)) + (x*4)) + 1 ],
                        bPixels.data[((y*(sx*4)) + (x*4)) + 1 ]
                    );
                    newPixels.data[((y*(sx*4)) + (x*4)) + 2 ] = Math.max(
                        aPixels.data[((y*(sx*4)) + (x*4)) + 2 ],
                        bPixels.data[((y*(sx*4)) + (x*4)) + 2 ]
                    );
                    newPixels.data[((y*(sx*4)) + (x*4)) + 3 ] = Math.max(
                        aPixels.data[((y*(sx*4)) + (x*4)) + 3 ],
                        bPixels.data[((y*(sx*4)) + (x*4)) + 3 ]
                    );
                }
            }
            break;
        case 'darken':
            for(var y = 0; y < sy; y++){
                for(x = 0; x < sx; x++){
                    newPixels.data[((y*(sx*4)) + (x*4))     ] = Math.min(
                        aPixels.data[((y*(sx*4)) + (x*4))     ],
                        bPixels.data[((y*(sx*4)) + (x*4))     ]
                    );
                    newPixels.data[((y*(sx*4)) + (x*4)) + 1 ] = Math.min(
                        aPixels.data[((y*(sx*4)) + (x*4)) + 1 ],
                        bPixels.data[((y*(sx*4)) + (x*4)) + 1 ]
                    );
                    newPixels.data[((y*(sx*4)) + (x*4)) + 2 ] = Math.min(
                        aPixels.data[((y*(sx*4)) + (x*4)) + 2 ],
                        bPixels.data[((y*(sx*4)) + (x*4)) + 2 ]
                    );
                    newPixels.data[((y*(sx*4)) + (x*4)) + 3 ] = Math.min(
                        aPixels.data[((y*(sx*4)) + (x*4)) + 3 ],
                        bPixels.data[((y*(sx*4)) + (x*4)) + 3 ]
                    );
                }
            }
            break;
        case 'overlay':
            var index, a_alpha, b_alpha;
            var x;
            for(var y = 0; y < sy; y++){
                for(x = 0; x < sx; x++){
                    index = ((y*(sx*4)) + (x*4));
                    a_alpha = aPixels.data[index  + 3];
                    if(a_alpha == 0){
                        newPixels.data[index    ] =  bPixels.data[index     ];
                        newPixels.data[index + 1 ] = bPixels.data[index + 1 ];
                        newPixels.data[index + 2 ] = bPixels.data[index + 2 ];
                        newPixels.data[index + 3 ] = bPixels.data[index + 3 ];
                    }else if (a_alpha == 255){
                        newPixels.data[index    ] =  aPixels.data[index     ];
                        newPixels.data[index + 1 ] = aPixels.data[index + 1 ];
                        newPixels.data[index + 2 ] = aPixels.data[index + 2 ];
                        newPixels.data[index + 3 ] = a_alpha;
                    }else{
                        //technically b should be a composite, and not use additive 
                        var a_combine_amount = a_alpha/255;
                        var b_combine_amount = (255-a_alpha)/255;
                        var b_alpha = bPixels.data[index  + 3];
                        newPixels.data[index    ] = 
                            (aPixels.data[index     ] * a_combine_amount) 
                            + (bPixels.data[index     ] * b_combine_amount)
                        ;
                        newPixels.data[index + 1 ] = 
                            (aPixels.data[index + 1 ] * a_combine_amount) 
                            + (bPixels.data[index + 1 ] * b_combine_amount)
                        ;
                        newPixels.data[index + 2 ] = 
                            (aPixels.data[index + 2 ] * a_combine_amount) 
                            + (bPixels.data[index + 2 ] * b_combine_amount)
                        ;
                        newPixels.data[index + 3 ] = Math.max(a_alpha, b_alpha);
                    }
                }
            }
            break;
    }
    (buffer || convolveBuffer.getContext('2d')).putImageData(newPixels, 0, 0, 0, 0, sx, sy);
    return newPixels;
}
export const dump = function(buffer, x, y){
    var data = '';
    var pos;
    for(var ypos = 0; ypos < y; ypos++){
        for(xpos = 0; xpos < x; xpos++){
            pos = ((ypos*(x*4)) + (xpos*4));
            data  += 
                buffer.data[pos    ].toString(16).toUpperCase() +
                buffer.data[pos + 1].toString(16).toUpperCase() +
                buffer.data[pos + 2].toString(16).toUpperCase() +
                buffer.data[pos + 3].toString(16).toUpperCase();
        }
        data += '\n';
    }
    return data;
}
export const composite = function(layers, height, width, returnType){
    // todo: top down opacity mask so opaque pixels aren't calculated below the level they achieve 100% opacity
    // (maybe hard to integrate with a bidirectional buffer)
    //var height = layers[0].height;
    //var width = layers[0].width;
    var buffer = new Canvas({ height, width });
    var context = buffer.getContext('2d');
    var pixels = context.getImageData(0,0, width, height);
    layers.forEach(function(layer){
        if(!layer.pixels) throw new Error('this layer has no pixels');
        pixels = merge(pixels, layer.pixels, context);
    });
    if(returnType === 'pixels' || returnType === undefined) return pixels;
    console.log(pixels);
    context.putImageData(pixels, 0, 0, 0, 0, width, height);
    if(returnType === 'canvas') return buffer;
    if(returnType === 'context' || returnType === 'context2d') return context;
}