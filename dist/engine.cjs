"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tool = exports.setBooth = exports.saveImage = exports.operate = exports.newLayer = exports.newImage = exports.merge = exports.filter = exports.dump = exports.decodeHex = exports.convolve = exports.composite = exports.brush = void 0;
var _environmentSafeCanvas = require("environment-safe-canvas/environment-safe-canvas.cjs");
var _layer = require("./layer.cjs");
var _darken = require("./compositors/darken.cjs");
var _lighten = require("./compositors/lighten.cjs");
var _overlay = require("./compositors/overlay.cjs");
var _booth = _interopRequireDefault(require("./booth.cjs"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const compositors = {
  darken: _darken.darken,
  lighten: _lighten.lighten,
  overlay: _overlay.overlay
};
const setBooth = booth => {
  // this is the object we find our various filters/brushes/ops/tools on
  registry = booth;
};
exports.setBooth = setBooth;
const tool = (layer, options) => {
  // operate on a path or location
  if (!options.name) throw new Error('engine not linked to image-booth');
  if (!registry.tools[options.name]) throw new Error('image-booth does not have tool ' + options.name);
  if (!layer.isCanvas) throw new Error('attempting to work on a layer generated by another engine');
};
exports.tool = tool;
const operate = (layer, options) => {
  // custom pixel logic
  if (!options.name) throw new Error('engine not linked to image-booth');
  if (!registry.operations[options.name]) throw new Error('image-booth does not have operation ' + options.name);
  if (!layer.isCanvas) throw new Error('attempting to work on a layer generated by another engine');
};
exports.operate = operate;
const saveImage = async (location, canvas, type = 'image/png', callback) => {
  try {
    const savePromise = _environmentSafeCanvas.Canvas.save(location, canvas, type);
    const result = await savePromise;
    if (callback) callback(null, result);
    return result;
  } catch (ex) {
    if (callback) callback(ex);else throw ex;
  }
};
exports.saveImage = saveImage;
const newLayer = async (options, callback) => {
  const layer = new _layer.Layer(options);
  await layer.ready;
  callback(layer);
  return layer;
};
exports.newLayer = newLayer;
const newImage = options => {
  return new Image(options);
};
exports.newImage = newImage;
const brush = (layer, options) => {
  // paint on a path
  if (!options.name) throw new Error('engine not linked to image-booth');
  if (!registry.brushes[options.name]) throw new Error('image-booth does not have brush ' + options.name);
  if (!layer.isCanvas) throw new Error('attempting to work on a layer generated by another engine');
};
exports.brush = brush;
const filter = (layer, options) => {
  // convolve
  if (!options.name) throw new Error('engine not linked to image-booth');
  if (!registry.filters[options.name]) throw new Error('image-booth does not have filter ' + options.name);
  if (!layer.isCanvas) throw new Error('attempting to work on a layer generated by another engine');
};
exports.filter = filter;
const decodeHex = clr => {
  const color = clr[0] === '#' ? clr.substring(1) : clr;
  var result = [parseInt(color.substring(0, 2), 16), parseInt(color.substring(2, 4), 16), parseInt(color.substring(4, 6), 16)];
  return result;
};
exports.decodeHex = decodeHex;
const convolve = function (pixels, filter, filter_div, offset, buffer) {
  const convolveBuffer = buffer || new _environmentSafeCanvas.Canvas({
    height: pixels.height,
    width: pixels.width
  });
  if (pixels == null) throw new Error('Tried to convolve nothing!');
  //setup buffer
  var context = convolveBuffer.getContext('2d', {
    willReadFrequently: true
  });
  var newPixels = context.getImageData(0, 0, pixels.width, pixels.height);
  var sx = pixels.width; //getx
  var sy = pixels.height; //gety
  var new_r, new_g, new_b, new_a, alpha, yv, pxl, new_pxl, kernel_size;
  var x, y;
  //kernel_size = filter.length; //coming soon
  for (y = 0; y < sy; y++) {
    for (x = 0; x < sx; x++) {
      new_r = new_g = new_b = 0;
      new_a = pixels.data[y * (sx * 4) + x * 4 + 3];
      //convolve this pixel to produce this pixel's value
      for (var j = 0; j < filter.length; j++) {
        //rows
        yv = Math.min(Math.max(y - 1 + j, 0), sy - 1);
        for (var i = 0; i < filter[j].length; i++) {
          //cols
          pxl = [Math.min(Math.max(x - 1 + i, 0), sx - 1), yv];
          if (filter[j] && filter[j][i]) {
            new_r += pixels.data[pxl[1] * (sx * 4) + pxl[0] * 4] * filter[j][i];
            new_g += pixels.data[pxl[1] * (sx * 4) + pxl[0] * 4 + 1] * filter[j][i];
            new_b += pixels.data[pxl[1] * (sx * 4) + pxl[0] * 4 + 2] * filter[j][i];
          }
        }
      }
      if (y >= 0 && y < sy) {
        //y coordinate in range?
        //
        if (offset && filter_div) {
          new_r = new_r / filter_div + offset;
          new_g = new_g / filter_div + offset;
          new_b = new_b / filter_div + offset;
        }
        //bound 0 .. 255
        new_r = new_r > 255 ? 255 : new_r < 0 ? 0 : new_r;
        new_g = new_g > 255 ? 255 : new_g < 0 ? 0 : new_g;
        new_b = new_b > 255 ? 255 : new_b < 0 ? 0 : new_b;
        //copy the altered values for this pixel into the buffer we created
        newPixels.data[y * (sx * 4) + x * 4] += new_r;
        newPixels.data[y * (sx * 4) + x * 4 + 1] += new_g;
        newPixels.data[y * (sx * 4) + x * 4 + 2] += new_b;
        newPixels.data[y * (sx * 4) + x * 4 + 3] += new_a;
      }
    }
  }
  // return the buffer
  return newPixels;
};
exports.convolve = convolve;
let convolveBuffer = null;
const merge = function (aPixels, bPixels, buffer, mode, opacity) {
  //src == image
  if (!convolveBuffer) convolveBuffer = new _environmentSafeCanvas.Canvas({
    width: aPixels.width,
    height: aPixels.height
  });
  //for clarity's sake, we are layering layer a over layer b
  if (aPixels == null || bPixels == null) throw new Error('Tried to convolve nothing!');
  if (aPixels.height != bPixels.height || aPixels.width != bPixels.width) {
    throw new Error(`Mismatched pixel size
            data: ${aPixels.data.length} vs ${bPixels.data.length}
            height: ${aPixels.height} vs ${bPixels.height}
            width: ${aPixels.width} vs ${bPixels.width}`);
  }
  if (mode == null) mode = 'overlay';
  //setup buffer
  var newPixels;
  if (!buffer || buffer == null) {
    //convolveBuffer.setProperty('width', aPixels.width);
    //convolveBuffer.setProperty('height', aPixels.height);
    convolveBuffer.width = aPixels.width;
    convolveBuffer.height = aPixels.height;
    var context = convolveBuffer.getContext('2d', {
      willReadFrequently: true
    });
    newPixels = context.getImageData(0, 0, aPixels.width, aPixels.height);
  } else {
    newPixels = buffer.getImageData(0, 0, aPixels.width, aPixels.height);
  }
  var sx = aPixels.width; //getx
  var sy = aPixels.height; //gety
  if (!compositors[mode]) throw new Error('Unkown mode: ' + mode);
  compositors[mode](aPixels, bPixels, newPixels);
  (buffer || convolveBuffer.getContext('2d', {
    willReadFrequently: true
  })).putImageData(newPixels, 0, 0, 0, 0, sx, sy);
  return newPixels;
};
exports.merge = merge;
const dump = function (buffer, x, y) {
  var data = '';
  var pos;
  for (var ypos = 0; ypos < y; ypos++) {
    for (xpos = 0; xpos < x; xpos++) {
      pos = ypos * (x * 4) + xpos * 4;
      data += buffer.data[pos].toString(16).toUpperCase() + buffer.data[pos + 1].toString(16).toUpperCase() + buffer.data[pos + 2].toString(16).toUpperCase() + buffer.data[pos + 3].toString(16).toUpperCase();
    }
    data += '\n';
  }
  return data;
};
exports.dump = dump;
const composite = function (layers, height, width, returnType = 'pixels') {
  // todo: top down opacity mask so opaque pixels aren't calculated below the level they achieve 100% opacity
  // (maybe hard to integrate with a bidirectional buffer)
  //var height = layers[0].height;
  //var width = layers[0].width;
  var buffer = new _environmentSafeCanvas.Canvas({
    height,
    width
  });
  var context = buffer.getContext('2d', {
    willReadFrequently: true
  });
  var pixels = context.getImageData(0, 0, width, height);
  layers.forEach(function (layer, index) {
    if (!layer.pixels) throw new Error('this layer has no pixels');
    pixels = merge(pixels, layer.pixels, context);
  });
  if (returnType === 'pixels') return pixels;
  context.putImageData(pixels, 0, 0, 0, 0, width, height);
  if (returnType === 'canvas') return buffer;
  if (returnType === 'context' || returnType === 'context2d') return context;
};
exports.composite = composite;